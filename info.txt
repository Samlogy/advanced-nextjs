Error handling page:
    create a custom page --> ex: 404.tsx, 500.tsx, ...
    add custom error page --> _error.tsx 

Middleware: run the code before is the request completed using:
    conditionning statement:
    matcher: url, url list

Internationalized routing: switch language with router 
    ex: .../fr/blog --> .../en/blog

react 18 features: we can use all react 18 new features along side nextjs

build-in:
    link - 
    image - 
    router - 
    script (execute script --> internal / external)
    head --> add additional headers (seo purpose, ...)

Rendering (Nextjs):
    CSR: same as react --> useffect, ...
    SSR: data is loaded from the server
    SSG: page is generated on build time on server, immediately display to user
    ISR: same as SSG attempt to re-generate the page every "certain interval of time in seconds"


Environment variable: 
    .env.local --> call this way (process.env.VARIABLE_NAME)

Eslint: yarn lint --> linting code / verify linting warings & errors

Debouncing: used for optimizing the performance. 
            It is done by limiting the rate of execution of a particular function 
            (also known as rate limiting).
            ex: avoid rendenring every time we update a state

Throttling: is same as debounce --> limiting the rate of execution of function.
    ex: avoid multiple click on button that triggers the same function

NB: throttling & debouncing improve code optimization

Portals: The Portal's most common use cases are when the child components need to visually break out of the parent container
    ex: Modal - notification - toast - alerts - tooltips - loaders - ...

HOC: Higher Order Component --> a fct that calls another fct which can be used for create a cpt / condition rendering

ForwardRef: its a ref that is passed to child cpt from parent cpt the child cpt must wrapped
    ex: React.forwardRef(component)

Perfomence: (Increase)
    fonts locally --> download & load them locally
    do not download unnecessary assets
    minifying css & js
    using CDN
    using code splitting
    use cache
    remove unused code
    lazy loading videos
    images: (use the right format)
        jpeg & jpg (the same) --> Photos and artwork.
        png > jpeg -->  illustrations and images (not piwelled like jpeg).
        svg (small size, scaled, animated) -->  Illustrations, logos, and icons.
        WebP > jpeg, png --> Photos, illustrations, etc.
        GIF (animated images) --> bigger size (use video instead)

        compress images to reduce size / redundancy
        responsive images according device size
        lazy load images
        scale down images to resonable size (according to website size)

Scale web app:
    *single server setup: (every web app/cache/DB is running on a single server)
        we can handle user's request a certain limiting point due to limiting ressources
        if server goes down the whole app is going down

    *Vertical Scaling vs Horizontal Scaling: 
        *vertical: (scale-up) -> we add more CPU /RAM for our servers
            pros: great for low traffic
            cons: doesn't support any failover- can't add unlimited CPU/RAM + costly
        *Horizontal: (scale-out) -> we add more servers to the pool
            pros: better for handling large amount of user's request
            
            NB: we add load balancer: it job is handle the traffic using different algorithms (Round Robin, ...), easy to scale (add more server into the pool)

            Database Replication: is used to scale database application using master-slave system. Here, master is our main database for that server and slaves are copies of the main database. 
            we use Master (create/update/delete operations), and the slaves for read (which much higher than any other operation)

            NB: 
                *otherwise when it reaches its load limit or fails for any reason our system can go down entirely
                *greater performences
                *reliability: if any accident occures our data is occied into multiple locations 
                             if master goes down: a slave take it place temporary runs recovery script (update-to-date)
                             if slave goes down: all read operations will be transffered to another DB

Tips:
    call for experience / help of more experienced ones in the field
    test code
    use documentation
    automate things when u can (increase productivity)
    learn about algorithms / data structures / computer science basics
    collaborate with people
    keep learnings


REST API:
    use patch over put (
        patch: partial update
        put: full update
    )
    endpoint naming
    standardization of response / error object
    add error / success message
    add HTTP status code
    each endpoint takes care of one single action & do it well (create services single action, do it well, and can be reusable)
    provide API documentation (
        endpoints available, and their purpose
        permission required to execute an endpoint
        example of endpoint invocation (response)
        error message to expect
    )
    use SSL / configure CORS
    version the API
    use cache --> performence
    Use standard UTC dates --> new Date().date.toISOString()
    add health check endpoint --> GET /health
